from machine import UART
from machine import Pin
import pycom

__version__ = '0.9.0'

PIN_MASK = 0b1010
COMM_PIN = 'P10'

class DeepSleep:

    WPUA_ADDR = const(0x09)
    OPTION_REG_ADDR = const(0x0E)
    IOCAP_ADDR = const(0x1A)
    IOCAN_ADDR = const(0x1B)

    WAKE_STATUS_ADDR = const(0x40)
    MIN_BAT_ADDR = const(0x41)
    SLEEP_TIME_ADDR = const(0x42)
    CTRL_0_ADDR = const(0x45)

    EXP_RTC_PERIOD = const(7000)

    def __init__(self):
        self.uart = UART(1, baudrate=10000, pins=(COMM_PIN, ))
        self.clk_cal_factor = 1
        self.uart.read()

    def _send(self, data):
        self.uart.write(bytes(data))

    def _start(self):
        self.uart.sendbreak(11)
        self._send([0x55])

    def _magic(self, address, and_val, or_val, xor_val, expected=None):
        self._start()
        self._send([address, and_val, or_val, xor_val])
        if expected is None:
            return self.uart.read()
        else:
            return self.uart.read(expected)

    def poke(self, address, value):
        self._magic(address, 0, value, 0)

    def peek(self, address):
        return self._magic(address, 0xFF, 0, 0)[6]

    def setbits(self, address, mask):
        self._magic(address, 0xFF, mask, 0)

    def clearbits(self, address, mask):
        self._magic(address, ~mask & 0xFF, 0, 0)

    def clear_set_bits(self, address, mask_clear, mask_set):
        self._magic(address, ~mask_clear & 0xFF, mask_set, 0)

    def togglebits(self, address, mask):
        self._magic(address, 0xFF, 0, mask)

    def calibrate(self):
        """ The microcontroller will send the value of CTRL_0 after setting the bit
            and then will send the following pattern through the data line:

               val | 1 | 0 | 1*| 0 | 1*| 0 | 1
               ms  | 1 | 1 | 1 | 1 | 8 | 1 | -

            The idea is to measure the real life duration of periods marked with *
            and substract them. That will remove any errors common to both measurements
            The result is 7 ms as generated by the PIC LF clock.
            It can be used to scale any future sleep value."""

        # setbits, but limit the number of received bytes to avoid confusion with pattern
        self._magic(CTRL_0_ADDR, 0xFF, 1 << 2, 0, 7)
        self.uart.deinit()
        Pin(COMM_PIN, mode=Pin.IN)
        pulses = pycom.pulses_get(COMM_PIN, 50000)
        self.uart = UART(1, baudrate=10000, pins=(COMM_PIN, ))
        self.clk_cal_factor  = (pulses[3][1] - pulses[1][1]) / EXP_RTC_PERIOD
        if self.clk_cal_factor > 1.25 or self.clk_cal_factor < 0.75:
            self.clk_cal_factor = 1

    def enable_auto_poweroff(self):
        self.setbits(CTRL_0_ADDR, 1 << 1)

    def set_pullups(self, mask):
        mask &= PIN_MASK
        if mask:
            self.clearbits(OPTION_REG_ADDR, 1 << 7)
        else:
            self.setbits(OPTION_REG_ADDR, 1 << 7)
        self.clear_set_bits(WPUA_ADDR, PIN_MASK, mask)

    def set_wake_on_raise(self, mask):
        self.clear_set_bits(IOCAP_ADDR, PIN_MASK, mask)

    def set_wake_on_fall(self, mask):
        self.clear_set_bits(IOCAN_ADDR, PIN_MASK, mask)

    def get_wake_status(self):
        # bits as they are returned from PIC:
        #   0: PIN 0 value after awake
        #   1: PIN 1 value after awake
        #   2: PIN 2 value after awake
        #   3: PIN 3 value after awake
        #   4: TIMEOUT
        #   5: RESET (or power-on)

        return self.peek(WAKE_STATUS_ADDR)

    def set_min_voltage_limit(self, value):
        value = int(((256 * 2.048) + (value / 2)) / value) # round to the nearest integer
        self.poke(MIN_BAT_ADDR, value)

    def go_to_sleep(self, seconds):
        self.calibrate()

        # the 1.024 factor is because the PIC LF operates at 31 KHz
        # WDT has a frequency divider to generate 1 ms
        # and then there is a binary prescaler, e.g., 1, 2, 4 ... 512, 1024 ms
        # hence the need for the constant

        seconds = int((seconds / (1.024 * self.clk_cal_factor)) + 0.5)  # round to the nearest integer
        self.poke(SLEEP_TIME_ADDR, (seconds >> 16) & 0xFF)
        self.poke(SLEEP_TIME_ADDR + 1, (seconds >> 8) & 0xFF)
        self.poke(SLEEP_TIME_ADDR + 2, seconds & 0xFF)
        self.setbits(CTRL_0_ADDR, 1 << 0)

    def hw_reset(self):
        self.setbits(CTRL_0_ADDR, 1 << 4)
